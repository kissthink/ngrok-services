#! /usr/bin/env node

var program = require('commander');
var fork = require('child_process').fork;
var spawn = require('child_process').spawn;
var fsPath = require('path');
var fs = require('fs');
var debug = require('debug')('ngrok-services:cli');

// default pid if parent does not provide one
var DEFAULT_PID_FILE = '.ngrok_services.pid';
// default config file name
var DEFAULT_CONFIG_FILE = 'ngrok_services.json';

// helper function to resolve the config file based on defaults, cwd and other
// factors.
function resolveConfigFile(input) {
  input = fsPath.resolve(input || DEFAULT_CONFIG_FILE);

  // if the file exists then return it
  if (!fs.existsSync(input)) {
    console.error('invalid config path %s not a directory or file', input);
    process.exit(1);
    return;
  }

  var stat = fs.statSync(input);

  // return file immediately
  if (stat.isFile()) return input;

  input = fsPath.join(input, DEFAULT_CONFIG_FILE);
  return input;
}

program.
  option('-p, --pid-file <path>', 'pid file location');

// resolve a pid file from the config file
function resolvePidFile(configFile) {
  if (program.pidFile) return fsPath.resolve(program.pidFile);
  return fsPath.join(fsPath.dirname(configFile), DEFAULT_PID_FILE);
}

// stop command
program.
  command('stop [config]').
  description('terminate ngrok tunneling').
  action(function(config, cmd) {
    var pidFile = resolvePidFile(resolveConfigFile(config));

    // XXX: some tools fail here but I don't care if its stopped already so exit
    // with success.
    if (!fs.existsSync(pidFile)) {
      process.exit(0);
      return;
    }

    // and now the ghetto spawn/kill :)
    var pid = fs.readFileSync(pidFile, 'utf8');
    var spawn = require('child_process').spawn;
    var killProc = spawn('kill', [pid], {
      // show output here
      stdio: 'inherit'
    });
  });

// start command
program.
  command('start [config]').
  description('start running ngrok with the config').
  action(function(config, cmd) {
    config = resolveConfigFile(config);

    // start the ngrok interface in a different process
    var proc = spawn(
      process.execPath,
      [__dirname + '/start.js'],
      {
        // don't share anything except IPC over a socket
        stdio: ['ignore', 'ignore', 'ignore', 'ipc'],
      }
    );

    var pidFile = resolvePidFile(config);

    // disallow multiple PID files so its easy to figure out who is who
    if (fs.existsSync(pidFile)) {
      console.error(
        'there may only be one pid file remove %s or stop the existing process',
        pidFile
      );
      process.exit(1);
    }

    // while an early exit of the child may kill the parent it will not pass up
    // the exit code. Watch for it correctly.
    function earlyExitHandler(code) {
      process.exit(code);
    }

    proc.once('exit', earlyExitHandler);
    proc.once('message', function(msg) {
      // write pure json so its easy to parse out
      process.stdout.write(JSON.stringify(msg));

      // remove exit listener
      proc.removeListener('exit', earlyExitHandler);

      // then detach
      proc.disconnect();
      proc.unref();
    });

    var options = { pidFile: pidFile };
    debug('launch ngrok services', config, options);

    // send the already parsed arguments
    proc.send([config, options]);
  });

program.parse(process.argv);
